% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/est.R
\name{est_radius}
\alias{est_radius}
\alias{crqa_radius}
\title{Estimate Radius.}
\usage{
est_radius(
  RM = NULL,
  y1 = NULL,
  y2 = NULL,
  emLag = 1,
  emDim = 1,
  method = "Euclidean",
  type = c("fixed", "optimal")[1],
  startRadius = NULL,
  eachRadius = 1,
  targetMeasure = c("RR", "DET", "LAM", "T1", "all")[1],
  targetValue = 0.05,
  tol = 0.1,
  maxIter = 100,
  theiler = NA,
  histIter = FALSE,
  noiseLevel = 0.75,
  noiseType = c("normal", "uniform")[1],
  plotROC = FALSE,
  standardise = c("mean.sd", "median.mad", "none")[3],
  radiusOnFail = c("tiny", "huge", "percentile")[1],
  silent = FALSE
)
}
\arguments{
\item{RM}{Unthresholded Recurrence Matrix}

\item{y1}{A numeric vector or time series}

\item{y2}{A numeric vector or time series for cross recurrence}

\item{emLag}{The embedding lag}

\item{emDim}{The embedding dimensions}

\item{method}{Distance measure to use. Any option that is valid for argument \code{method} of \code{\link[proxy:dist]{proxy::dist()}}. Type \code{proxy::pr_DB$get_entries()} to see a list of all the options. Common methods are: "Euclidean", "Manhattan", "Minkowski", "Chebysev" (or the same but shorter: "L2","L1","Lp" and "max" distance) (default = \code{"Euclidean"})}

\item{type}{Either \code{"fixed"} (default) or \code{"optimal"}, \code{"fixed"} will search for a radius that is close to the value for the \code{targetMeasure} in \code{targetValue}, \code{"optimal"} will optimise the radius for the \code{targetMeasure}, \code{targetValue} is ignored.}

\item{startRadius}{If \code{type = "fixed"} this is the starting value for the radius (default = percentile of unique distances in RM given by \code{targetValue}). If \code{type = "optimal"} this will be a range of radius values (in normalised SD units) that will be considered (default = \code{seq(0,2,by=.01)})}

\item{eachRadius}{If \code{type = "optimal"} this is the number of signal and noise series that will be generated for each level in \code{startRadius} (default = \code{1})}

\item{targetMeasure}{If \code{type = "optimal"}, it must be a character vector indicating which recurrence measure to optimise the radius for, options are "RR" (default), "DET", "LAM", "T1", and "all". The option \code{targetMeasure = "all"} will report all the optimal values obtained from one realisation of \code{startRadius * eachRadius} signal and noise series.}

\item{targetValue}{When argument \code{type} is set to "fixed", the value represents the target value for the measure in \code{targetMeasure} (default = \code{RR = .05}).}

\item{tol}{Tolerance for achieving \code{targetValue} for \code{targetMeasure} (default = \code{0.1})}

\item{maxIter}{If \code{type = "fixed"}: Maximum number of iterations to reach targetValue.}

\item{theiler}{Size of theiler window (default \code{0})}

\item{histIter}{Return iteration history? (default = \code{FALSE})}

\item{noiseLevel}{Noise level to construct the \verb{signal + noiseLevel *} \eqn{N(\mu=0,\sigma=1)} (default = \code{0.75})}

\item{noiseType}{Type}

\item{plotROC}{Generates an ROC plot if \code{type = "optimal"}}

\item{standardise}{Standardise \code{y} if \code{type == "optimal"}}

\item{radiusOnFail}{Radius to return when search fails \verb{"tiny" = 0 + ,Machine.double.eps}, this will likely cause a matrix full of zeros. \verb{"huge" = 1 + max. distance in RM}, which will give a matrix full of ones, \verb{"percentile" = quantile(RM, prob = targetValue) of distances greater than 0}.}

\item{silent}{Silent-ish}
}
\value{
A dataframe listing settings ussed to search for the radius, the radius found given the settings and the recurrence rate produced by the radius (either 1 row or the entire iteration history)
}
\description{
Find a fixed or optimal radius.
}
\seealso{
Other Estimate Recurrence Parameters: 
\code{\link{est_emDim}()},
\code{\link{est_emLag}()},
\code{\link{est_parameters_roc}()},
\code{\link{est_parameters}()}
}
\concept{Estimate Recurrence Parameters}
