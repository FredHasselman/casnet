% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/helpers.R
\name{elascer}
\alias{elascer}
\title{Elastic Scaler - A Flexible Rescale Function}
\usage{
elascer(
  x,
  mn = NA,
  mx = NA,
  lo = 0,
  hi = 1,
  groupwise = FALSE,
  keepNA = TRUE,
  boundaryPrecision = NA,
  tol = .Machine$double.eps^0.5
)
}
\arguments{
\item{x}{Input vector or data frame.}

\item{mn}{Minimum value of original, defaults to \code{min(x, na.rm = TRUE)} if set to \code{NA}.}

\item{mx}{Maximum value of original, defaults to \code{max(x, na.rm = TRUE)} if set to \code{NA}.}

\item{lo}{Minimum value to rescale to, defaults to \code{0}.}

\item{hi}{Maximum value to rescale to, defaults to \code{1}.}

\item{groupwise}{If \code{x} is a data frame with \verb{2+} columns, \code{mn = NA} and/or \code{mx = NA} and \code{groupwise = TRUE}, scaling will occur}

\item{keepNA}{Keep \code{NA} values?}

\item{boundaryPrecision}{If set to \code{NA} the precision of the input will be the same as the precision of the output. This can cause problems when detecting values that lie just outside of, or, exactly on boundaries given by \code{lo} and \code{hi}, e.g. after saving the data using a default precision. Setting \code{boundaryPrecision} to an integer value will ensure that the boundaries of the new scale are given by \code{round(..., digits = boundaryPrecision)}. Alternatively one could just round all the output after rescaling to a desired precision (default = \code{NA})}

\item{tol}{The tolerance for deciding wether a value is on the boundary \code{lo} or \code{hi} (default = \verb{.Machine$double.eps^0.5)})}
}
\value{
scaled inout
}
\description{
The 'elastic scaler'will rescale numeric vectors (1D, or columns in a matrix or data.frame) to a user defined minimum and maximum, either based on the extrema in the data, or, a minimum and maximum defined by the user.
}
\details{
Three uses:
\enumerate{
\item elascer(x)             - Scale x to data range: min(x.out)==0;      max(x.out)==1
\item elascer(x,mn,mx)       - Scale x to arg. range: min(x.out)==mn==0;  max(x.out)==mx==1
\item elascer(x,mn,mx,lo,hi) - Scale x to arg. range: min(x.out)==mn==lo; max(x.out)==mx==hi
}
}
\examples{
# Works on numeric objects
somenumbers <- cbind(c(-5,100,sqrt(2)),c(exp(1),0,-pi))

# Using the defaults:
# 1. mn and mx are derived globally (groupWise = FALSE)
# 2. values rescaled to hi and lo are integers, 0 and 1 respectively
elascer(somenumbers)

# If the data contain values < mn they will return as < lo
elascer(somenumbers,mn=-100)
# If the data contain values > mx they will return > hi
elascer(somenumbers,mx=99)

# Effect of setting groupWise
elascer(somenumbers,lo=-1,hi=1)
elascer(somenumbers,lo=-1,hi=1, groupwise = TRUE)

elascer(somenumbers,mn=-10,mx=100,lo=-1,hi=4)
elascer(somenumbers,mn= NA,mx=100,lo=-1,hi=4, groupwise = TRUE)

# Effect of setting boundaryPrecision
x <- rbind(1/3, 1/7)

re1 <- elascer(x, lo = 0, hi = 1/13, boundaryPrecision = NA)
max(re1)==0.07692308 # FALSE
max(re1)==1/13       # TRUE

re2 <- elascer(x, lo = 0, hi = 1/13, boundaryPrecision = 8)
max(re2)==0.07692308 # TRUE
max(re2)==1/13       # FALSE

}
