% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ts.R
\name{ts_levels}
\alias{ts_levels}
\title{Detect levels in time series}
\usage{
ts_levels(
  y,
  minDataSplit = NROW(y)/5,
  minLevelDuration = round(minDataSplit/3),
  changeSensitivity = 0.01,
  maxLevels = 30,
  method = c("anova", "poisson", "class", "exp")[1],
  crossValidations = 10,
  minChange = NA,
  returnTrends = FALSE,
  Trend_minDataSplit = minDataSplit,
  Trend_minLevelDuration = minLevelDuration,
  Trend_changeSensitivity = changeSensitivity,
  Trend_maxLevels = maxLevels,
  Trend_method = method,
  Trend_crossValidations = crossValidations,
  Trend_minChange = NA,
  doLevelPlot = FALSE,
  doTreePlot = FALSE,
  returnTree = FALSE,
  returnPlot = FALSE,
  silent = FALSE
)
}
\arguments{
\item{y}{A time series of numeric vector}

\item{minDataSplit}{An integer indicating how many datapoints should be in a segment before it will be analysed for presence of a level or trend change (default = \code{12})}

\item{minLevelDuration}{Minimum duration (number of datapoint) of a level (default = \code{round(minDataSplit/3)})}

\item{changeSensitivity}{A number indicating a criterion of change that must occur before declaring a new level. Higher numbers indicate higher levels of change must occur before a new level is considered. For example, if \code{method = "anova"}, the overall \code{R^2} after a level is introduced must increase by the value of \code{changeSensitivity}, see the \code{cp} parameter in \code{\link[rpart:rpart.control]{rpart::rpart.control()}}. (default = \code{0.01})}

\item{maxLevels}{Approximately the maximum number of levels tht will be detectd. The value indicates the node-depth of the final tree with the root node being depth 0, see \code{\link[rpart:rpart.control]{rpart::rpart.control()}} argument \code{maxdepth} (default = 30)}

\item{method}{The partitioning method to use, see the manual pages of \link{rpart} for details.}

\item{crossValidations}{The number of cross-validations (default = \code{10})}

\item{minChange}{After the call to \link{rpart}, adjust detected level changes to a minimum absolute change in \code{y}, e.g. \code{sd(y)} or in case of a discrete scale, a minimal scale change that represents significant level change relative to the interpretation of the scale. If a level change is smaller than \code{minChange}, the previous level will be continued. Note that this is an iterative process starting at the beginning of the series and 'correcting' towards the end. The results are stored in \code{p_adj}. Set to \code{NA} to skip, which means \code{p_adj} will be identical to \code{p} (default  = \code{NA})}

\item{returnTrends}{Should stationary trends also be estimated and returned? Unless otherwise specified, the arguments will be the same as for the level detection and argument \code{minChange} will be ignored for trends. This command will just run \code{ts_levels(diff(y))} and add the slope segments and values to the level plot. See \code{examples} on how to create a custom plot (default = \code{FALSE})}

\item{Trend_minDataSplit}{see \code{minDataSplit}}

\item{Trend_minLevelDuration}{see \code{minLevelDuration}}

\item{Trend_changeSensitivity}{see \code{changeSensitivity}}

\item{Trend_maxLevels}{see \code{maxLevels}}

\item{Trend_method}{see \code{method}}

\item{Trend_crossValidations}{see \code{crossValidations}}

\item{Trend_minChange}{see \code{minChange}}

\item{doLevelPlot}{Should a plot with the original series and the levels and/or trends be produced? If \code{returnTrends = TRUE} sloped regions will be displayed as segments (default = \code{FALSE})}

\item{doTreePlot}{Should a plot of the decision tree be produced. If \code{returnTrends = TRUE} there will be 2 trees. This requires package \href{https://cran.r-project.org/web/packages/partykit/index.html}{partykit}. Use \link[grid:grid.grab]{grid::grid.grab} to grab the tree plot object as a grob (default = \code{FALSE})}

\item{returnTree}{should the tree object from \link{rpart} be returned in the output? (default = \code{FALSE})}

\item{returnPlot}{if \code{TRUE} returns the levelplot as a \link{ggplot2} object (default = \code{FALSE})}

\item{silent}{silent(-ish) mode}
}
\value{
A list object with fields \code{tree} and \code{pred}. The latter is a data frame with columns \code{x} (time), \code{y} (the variable of interest) and \code{p} the predicted levels in \code{y} and \code{p_adj}, the levels in \code{p} but adjusted for the value passed to \code{minChange}.
}
\description{
Use recursive partitioning function \code{\link[rpart:rpart]{rpart::rpart()}} to perform a 'classification' of relatively stable levels in a timeseries.
}
\examples{

# Levels in white noise?

set.seed(4321)
y <- rnorm(100)
wn <- ts_levels(y)
plot(wn$pred$x,wn$pred$y, type = "l")
lines(wn$pred$p, col = "red3", lwd = 2)

# This is due to the default changeSensitivity of 0.01

wn2 <- ts_levels(y,changeSensitivity = .1)
lines(wn2$pred$p, col = "steelblue", lwd = 2)


}
\seealso{
Other Time series operations: 
\code{\link{ts_center}()},
\code{\link{ts_changeindex}()},
\code{\link{ts_checkfix}()},
\code{\link{ts_detrend}()},
\code{\link{ts_diff}()},
\code{\link{ts_discrete}()},
\code{\link{ts_duration}()},
\code{\link{ts_embed}()},
\code{\link{ts_integrate}()},
\code{\link{ts_peaks}()},
\code{\link{ts_permtest_block}()},
\code{\link{ts_permtest_transmat}()},
\code{\link{ts_rasterize}()},
\code{\link{ts_sd}()},
\code{\link{ts_slice}()},
\code{\link{ts_slopes}()},
\code{\link{ts_standardise}()},
\code{\link{ts_sumorder}()},
\code{\link{ts_symbolic}()},
\code{\link{ts_trimfill}()},
\code{\link{ts_windower}()}
}
\author{
Fred Hasselman
}
\concept{Time series operations}
