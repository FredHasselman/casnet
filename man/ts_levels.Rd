% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ts.R
\name{ts_levels}
\alias{ts_levels}
\title{Detect levels in time series}
\usage{
ts_levels(
  y,
  minDataSplit = NROW(y)/4,
  minLevelDuration = round(minDataSplit/3),
  changeSensitivity = 0.01,
  maxLevels = floor(NROW(y)/minLevelDuration),
  method = c("anova", "poisson", "class", "exp")[1],
  minChange = NA,
  returnTrends = FALSE,
  minTrendDuration = max(minLevelDuration, 2),
  maxTrends = maxLevels,
  removeTrendsLarger = c(-0.1, 0.1),
  removeTrendsShorter = minTrendDuration,
  doLevelPlot = FALSE,
  doTreePlot = FALSE,
  silent = FALSE
)
}
\arguments{
\item{y}{A time series of numeric vector}

\item{minDataSplit}{An integer indicating how many datapoints should be in a segment before it will be analysed for presence of a level or trend change (default = \code{12})}

\item{minLevelDuration}{Minimum duration (number of datapoint) of a level (default = \code{round(minDataSplit/3)})}

\item{changeSensitivity}{A number indicating a criterion of change that must occur before declaring a new level. Higher numbers indicate higher levels of change must occur before a new level is considered. For example, if \code{method = "anova"}, the overall \code{R^2} after a level is introduced must increase by the value of \code{changeSensitivity}, see the \code{cp} parameter in \code{\link[rpart:rpart.control]{rpart::rpart.control()}}. (default = \code{0.01})}

\item{maxLevels}{Maximum number of levels in one series (default = floor(max(NROW(y), na.rm = TRUE)/minLevelDuration))}

\item{method}{The partitioning method to use, see the manual pages of \link{rpart} for details.}

\item{minChange}{After the call to \link{rpart}, adjust detected level changes to a minimum absolute change in \code{y}. If a level change is smaller than \code{minChange}, the previous level will be continued. Note that this is an iterative process starting at the beginning of the series and 'correcting' towards the end. The results are stored in \code{p_adj}. Set to \code{NA} to skip, which means \code{p_adj} will be identical to \code{p} (default  = \code{sd(y, na.rm = TRUE)})}

\item{returnTrends}{Should stationary trends also be estimated and returned? Arguments \code{method} and \code{changeSensitivity} will be the same as for level detection and argument \code{minChange} will be ignored. (default = \code{FALSE})}

\item{minTrendDuration}{Required if \code{returnTrends = TRUE}, the minimum duration for a trend. (default = \code{max(minLevelDuration, 2)})}

\item{maxTrends}{Maximum number of trends in one series. (default = \code{maxLevels})}

\item{removeTrendsLarger}{Pass \code{NA} to ignore. If there are trends in the data, remove them before estimating stationary levels to improve accuracy. Provide a 2 element vector representing a range of slope values that can reasonably be considered a weakly stationary level. If \code{removeTrendsLarger} is not \code{NA} it takes precedence over \code{removeTrendShorter}. (default = \code{c(-0.1, 0.1)})}

\item{doLevelPlot}{Should a plot with the original series and the levels and/or trends be produced? (default = \code{FALSE})}

\item{doTreePlot}{Should a plot of the decision tree be produced. If \code{returnTrends = TRUE} there will be 2 trees. This requires package \href{https://cran.r-project.org/web/packages/partykit/index.html}{partykit} (default = \code{FALSE})}

\item{silent}{silent(-ish) mode}

\item{removeTrendShorter}{Pass \code{NA} to ignore. If there are trends in the data, remove them before estimating stationary levels. Provide a trend duration in terms of data points that can reasonably be considered a period of transient behaviour before a new stationary level is reached. If \code{removeTrendsLarger} is not \code{NA} it takes precedence over \code{removeTrendShorter}. (default = \code{5})}
}
\value{
A list object with fields \code{tree} and \code{pred}. The latter is a data frame with columns \code{x} (time), \code{y} (the variable of interest) and \code{p} the predicted levels in \code{y} and \code{p_adj}, the levels in \code{p} but adjusted for the value passed to \code{minChange}.
}
\description{
Use recursive partitioning function \code{\link[rpart:rpart]{rpart::rpart()}} to perform a 'classification' of relatively stable levels in a timeseries.
}
\examples{

# Levels in white noise?

set.seed(4321)
y <- rnorm(100)
wn <- ts_levels(y)
plot(wn$pred$x,wn$pred$y, type = "l")
lines(wn$pred$p, col = "red3", lwd = 2)

# This is due to the default changeSensitivity of 0.01

wn2 <- ts_levels(y,changeSensitivity = .1)
lines(wn2$pred$p, col = "steelblue", lwd = 2)


}
\seealso{
Other Time series operations: 
\code{\link{ts_center}()},
\code{\link{ts_changeindex}()},
\code{\link{ts_checkfix}()},
\code{\link{ts_detrend}()},
\code{\link{ts_diff}()},
\code{\link{ts_discrete}()},
\code{\link{ts_duration}()},
\code{\link{ts_embed}()},
\code{\link{ts_integrate}()},
\code{\link{ts_peaks}()},
\code{\link{ts_permtest_block}()},
\code{\link{ts_permtest_transmat}()},
\code{\link{ts_rasterize}()},
\code{\link{ts_sd}()},
\code{\link{ts_slice}()},
\code{\link{ts_slopes}()},
\code{\link{ts_standardise}()},
\code{\link{ts_sumorder}()},
\code{\link{ts_symbolic}()},
\code{\link{ts_trimfill}()},
\code{\link{ts_windower}()}
}
\author{
Fred Hasselman
}
\concept{Time series operations}
